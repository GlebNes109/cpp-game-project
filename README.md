## Bomberman

<div style="text-align: center;font-size: 24px; font-weight: bold;">
  Команда СНГ++
</div>

### Уникальность идеи
Это консольная версия bomberman, предназначенная для комфортной игры без использования графического окружения. Если вы установили linux, но еще не успели поставить окружение и вам срочно надо поиграть в бомбермена - эта игра для вас!

### Инструкция по запуску на MacOS (стабильность не гарантируется)
Может не работать на MacBook с Intel процессорами.
Установите ncurses (предварительно установить homebrew)
```
brew install ncurses
```
билд проекта:
```
g++ -std=c++17 main.cpp GameSpaceController.cpp BombController.cpp EnemyController.cpp PlayerController.cpp -o bomberman -lncursesw \
    -I/opt/homebrew/opt/ncurses/include \
    -L/opt/homebrew/opt/ncurses/lib
```
запуск проекта:
```
./bomberman
```

### Инструкция по запуску на Ubuntu

предварительно установить библиотеку ncurses:

```
sudo apt install libncurses5-dev libncursesw5-dev
```

для запуска выполните в терминале:
```
g++ main.cpp GameSpaceController.cpp BombController.cpp EnemyController.cpp PlayerController.cpp -o bomberman -lncurses && ./bomberman
```


### Идея
В качестве проекта мы выбрали консольную версию Bomberman на C++. 
Механика игры будет изменена по сравнению с оригинальной игрой. 
*примерные* требования (могут немного измениться в будущем)

**Описание представленного функционала**
* Уровни нарисованы единоразово, автогенерации уровней нет
* Уровни представляют из себя лабиринт на поле из клеток N x N клеток, каждая клетка - это либо стена, либо свободное пространство.
* Геймплей - игрок может двигаться вверх/вниз/влево/вправо по кнопкам wasd, может ставить бомбы на кнопку F, которые уничтожают врагов. Цель - уничтожить всех врагов
* Бомба взрывается по X и по Y на N клеток через секунду после установки.
* Игрок может ставить только определенное количество бомб
* Враги рассчитывают растояние до игрока и делают оптимальный ход (ИИ для врагов)
* Игровое поле в терминале обновляется с помощью библиотеки ncurses и с использованием различных цветов для отрисовки разных частей игры (игрок отрисовывается зеленым цветом, бомбы - желтым, враги - красным)

**Системные требования**
* ОС Linux, любой дистрибутив
* 15 мб свободного места
* ncurses

### Команда

- Захар - разработчик
- Глеб - техлид
- Антон - дизайнер
  Сложность и обьем кода
  Архитектура
  Баги
  Формат кода
  Условные правила приличия
  
- Общие баллы:
  Уникальность Идеи +0.5Б
  Сложность и объём кода +1Б
  Архитектура +0.5Б
  Баги +0.5Б
  Презентация +0.5Б
  Командообразование +1Б
  UI +0Б
  UX +1Б
  Формат кода +0.5Б
  Условные правила приличия +0.5Б
  Соблюдение дедлайнов +1Б
  0.5Б за смелость

### Формат выполнения 

github - этот репозиторий (ссылка - https://github.com/GlebNes109/cpp-game-project)

### Структура проекта (документация)

Структура проекта довольно простая, и в то же время этот проект можно легко масштабировать. Все слои логики разделены на отдельные классы - например, логика ИИ для врагов в EnemyController, отрисовка и контроль всего игрового пространства в GameSpaceController и т д. Это позволит легко добавить функционал в будущем без изменения остальных классов и без ошибок

#### Отрисовка врагов, бомб, взрывов и хранение текущего состояния

В main (основном файле) инициализируются векторы, хранящие информацию о врагах, бомбах и взрывах. Далее во все остальные классы (контроллеры) передаются ссылки на эти массивы, что позволяет менять их в одном контроллере, и затем отрисовывать в другом. Отрисовка происходит в основном игровом цикле каждые 0.001 секунд

#### Таймеры

Таймеры нужны для того чтобы корректно двигать врагов, если просто двигать врагов, то они будут двигаться очень быстро, поэтому между сдвигами врагов делается пауза. В самом начале работы программы засекаются все таймеры, после чего по истечении времени выполняется сдвиг врагов. Игрок также двигается по таймеру, это необходимо чтобы ограничить его скорость. В противном случае его скорость будет зависеть только от того, насколько быстро он нажимает кнопки, что было бы неправильно

#### Взрыв бомбы

У каждой бомбы есть счетчик времени до взрыва. Каждые 0.2 секунды счетчик каждой бомбы тикает на -1, и состояние всех бомб обновляется - если счетчик достигает 0, происходит взрыв. Взрыв - это отдельная структура, которая добавляется в вектор со взрывами и отрисовывается так же как и другие части игры.

#### ИИ для врагов

Враги преследуют игрока, алгоритм движения врагов - вычисляется разница между координатами врага и игрока, после чего враг идет по той координате, где эта разница больше. Если враг не может идти в ту сторону, он идет в сторону игрока, но туда, где разница меньше. В случае, если и тут препятствие, враг идет туда, где препятствия нет.

## Итоговое оценивание

### Общие критерии для проекта

#### Сложность и объем кода
Код разделен на классы и распределен по отдельным файлам. Он читаемый, есть разделение реализации методов класса и объявления классов. В стеке есть библиотеки (chrono, ncurses), которые не изучались на парах, но которые нужны для игры и которые изучались самостоятельно. Игра просиходит в real time, что также сильно ее усложняет - из-за этого добавляются таймеры, проверки на условия победы/поражения и т д. Одними из самых сложных вещей по коду были:

* Отрисовка всех объектов и проверка касания игрока в врагом
* Отрисовка взрыва бомбы и корректный расчет радиуса поражения
* Поражение врагов и игрока бомбами (взрывами от них)
* Расчет ходов для врагов, проверки на стены для врагов, проверки на то, что враг не налезает на врага

#### Архитектура

Весь код разделен на слои, а ключевые обьекты (GameSpaceController и векторы с игровыми элементами) передаются по ссылкам и изменяются контроллерами. Это позволяет, к примеру, добавить новго врага, но не отрисовывать его прямо в EnemyController, ведь за отрисовку отвечает отдельный класс. есть разделение реализации методов и обьявление класса (заголовочные файлы), это также делает архитектуру проекта более гибкой, а код читаемым. Отдельный класс GameSpaceController отрисовывает все векторы с игровыми обьектами (бомбы, взрывы, враги), что делает архитектуру очень гибкой. Можно безболезненно и быстро добавлять новые фичи (например, можно добавить еще несколько видов бомб), можно добавить несколько уровней, предметы на уровнях и тд. Все это не потребует рефакторинга уже существующего кода и не вызовет багов.

Более подробно гибкость и масштабируемость архитектуры расписаны выше, в секции "Структура проекта". 

#### Баги
С багами все просто. Их нет.

#### Презентация
Все участники проекта уверенно рассказывали свою часть, понимали как работает код который они презентуют

#### UI
У проекта очень привлекательный интерфейс, все отрисовано разными цветами, нет слишком ярких или темных цветов которые бы сильно отвелкали от игры. Благодаря разноцветной отрисовке в термианле, враги и бомбы хорошо заметны.

#### UX
Клавиши интуитивно понятны, WASD - ходьба персонажа по классике, E - exit - выход, F - поставить бомбу (очень удобная кнопка рядом с wasd, которую можно нажимать в процессе игры не задействуя вторую руку). Символы соотвествуют своему смыслу - E (enemy) - враг, B (bomb) - бомба, P (player) - игрок. Для лучшего понимания происходящего стены были покрашены в серый цвет, так как они не должны сильно отвелкать и бросаться в глаза, враги - красные, что подчеркивает их, бомба - желтая, что тоже привлекает внимание. При проигрыше или выигрыше показывается соотвествующий текст (game over или you win). UX полностью понятен

##### Формат кода
Есть хорошая документация и комментарии везде, где они могут быть нужны

#### Правила приличия
Все описанные правила приличия соблюдены (auto типов нет, символы берутся из констант, и тд)

#### Соблюдение дедлайнов
Все дедлайны были соблюдены

#### Экстра балл
Алгоритмы в проекте (отрисовка взрывов, проверка столкновений, логика врагов) заслуживают экстра балла, а также 0.5 баллов за смелость (мы выступили первыми)
